type Query {
  osTime: String!

  """
  you need to be authenticated to call this resolver
  """
  authenticated: Boolean!
  me: UserQuery!
  currentDevice: DeviceQuery!
  webInputs(host: String!): [WebInputGQL!]!
}

type UserQuery {
  id: ID!
  email: EmailAddress
  tokenVersion: Int!
  username: String
  uiLocalisation: String!
  addDeviceSecretEncrypted: String!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  deviceRecoveryCooldownMinutes: Int!
  autofill: Boolean!
  language: String!
  theme: String!
  Token: [TokenGQL!]!
  masterDevice: DeviceGQL
  recoveryDecryptionChallenge: DecryptionChallengeGQL
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
  MasterDeviceChange: [MasterDeviceChangeGQL!]!
  devices: [DeviceQuery!]!
  device(id: UUID!): DeviceQuery!
  lastChangeInSecrets: DateTime
  devicesCount: Int!
  primaryEmailVerification: EmailVerificationGQLScalars
  emailVerifications: [EmailVerificationGQLScalars!]!
  encryptedSecrets(fromDate: DateTime): [EncryptedSecretQuery!]!
  sendAuthMessage(
    pageName: String!
    device: String!
    time: DateTime!
    location: String!
  ): Boolean!
  decryptionChallengesWaiting: [DecryptionChallengeForApproval!]!
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

type TokenGQL {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime
  type: TokenType!
  emailToken: String
  valid: Boolean!
  expiration: DateTime!
  userId: String!
  user: UserGQL!
}

enum TokenType {
  EMAIL
  API
}

type UserGQL {
  id: ID!
  email: String
  tokenVersion: Int!
  username: String
  uiLocalisation: String!
  addDeviceSecretEncrypted: String!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  deviceRecoveryCooldownMinutes: Int!
  autofill: Boolean!
  language: String!
  theme: String!
  Token: [TokenGQL!]!
  masterDevice: DeviceGQL
  recoveryDecryptionChallenge: DecryptionChallengeGQL
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
  MasterDeviceChange: [MasterDeviceChangeGQL!]!
}

type DeviceGQL {
  id: ID!
  firstIpAddress: String!
  lastIpAddress: String!
  firebaseToken: String!
  name: String!
  platform: String!
  ipAddressLock: Boolean!
  logoutAt: DateTime
  syncTOTP: Boolean!
  vaultLockTimeoutSeconds: Int
  createdAt: DateTime!
  updatedAt: DateTime
  registeredWithMasterAt: DateTime
  lastSyncAt: DateTime
  lastUnlockAt: DateTime
  lastLockAt: DateTime
  masterPasswordOutdatedAt: DateTime
  userId: String!
  User: UserGQL!
  UserMaster: UserGQL
  SecretUsageEvents: [SecretUsageEventGQL!]!
  DeviceDecryptionChallengesApproved: [DecryptionChallengeGQL!]!
}

type SecretUsageEventGQL {
  id: ID!
  kind: String!
  timestamp: DateTime!
  secretId: String!
  url: String
  userId: String!
  deviceId: String!
  webInputId: Int
  Secret: EncryptedSecretGQL!
  User: UserGQL!
  Device: DeviceGQL!
  WebOTPInput: WebInputGQL
}

type EncryptedSecretGQL {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
  SecretUsageEvent: [SecretUsageEventGQL!]!
}

enum EncryptedSecretType {
  TOTP
  LOGIN_CREDENTIALS
}

type WebInputGQL {
  id: Int!
  layoutType: String
  createdAt: DateTime!
  host: String!
  url: String!
  kind: WebInputType!
  domPath: String!
  domOrdinal: Int!
  addedByUserId: String!
  addedByUser: UserGQL!
  UsageEvents: [SecretUsageEventGQL!]!
}

enum WebInputType {
  TOTP
  USERNAME
  EMAIL
  USERNAME_OR_EMAIL
  PASSWORD
  NEW_PASSWORD
  NEW_PASSWORD_CONFIRMATION
  SUBMIT_BUTTON
  CUSTOM
}

type DecryptionChallengeGQL {
  id: Int!
  masterPasswordVerifiedAt: DateTime
  approvedAt: DateTime
  rejectedAt: DateTime
  blockIp: Boolean
  deviceName: String!
  deviceId: String!
  userId: String!
  createdAt: DateTime!
  approvedByRecovery: Boolean!
  approvedFromDeviceId: String
  user: UserGQL!
  approvedFromDevice: DeviceGQL
  User: [UserGQL!]!
}

type TagGQL {
  id: Int!
  name: String!
  createdAt: DateTime!
  userId: String!
  user: UserGQL!
}

type UserPaidProductsGQL {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime
  expiresAt: DateTime
  productId: String!
  userId: String!
  checkoutSessionId: String!
  user: UserGQL!
}

type MasterDeviceChangeGQL {
  id: ID!
  createdAt: DateTime!
  processAt: DateTime!
  oldDeviceId: String!
  newDeviceId: String!
  userId: String!
  user: UserGQL!
}

type DeviceQuery {
  id: ID!
  firstIpAddress: String!
  lastIpAddress: String!
  firebaseToken: String!
  name: String!
  platform: String!
  ipAddressLock: Boolean!
  logoutAt: DateTime
  syncTOTP: Boolean!
  vaultLockTimeoutSeconds: Int
  createdAt: DateTime!
  updatedAt: DateTime
  registeredWithMasterAt: DateTime
  lastSyncAt: DateTime
  lastUnlockAt: DateTime
  lastLockAt: DateTime
  masterPasswordOutdatedAt: DateTime
  userId: String!
  User: UserGQL!
  UserMaster: UserGQL
  SecretUsageEvents: [SecretUsageEventGQL!]!
  DeviceDecryptionChallengesApproved: [DecryptionChallengeGQL!]!
  encryptedSecretsToSync: [EncryptedSecretQuery!]!
  lastGeoLocation: String!
}

type EncryptedSecretQuery {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
  SecretUsageEvent: [SecretUsageEventGQL!]!
  lastUsedAt: DateTime
}

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

type EmailVerificationGQLScalars {
  address: ID!
  createdAt: DateTime!
  verifiedAt: DateTime
  userId: String!
  kind: EmailVerificationType!
}

enum EmailVerificationType {
  PRIMARY
  CONTACT
}

type DecryptionChallengeForApproval {
  id: Int!
  rejectedAt: DateTime
  createdAt: DateTime!
  deviceName: String!
  deviceId: UUID!
}

type Mutation {
  """
  you need to be authenticated to call this resolver
  """
  me: UserMutation!
  currentDevice: DeviceMutation!
  registerNewUser(
    userId: UUID!
    input: RegisterNewAccountInput!
  ): LoginResponse!

  """
  returns a decryption challenge
  """
  deviceDecryptionChallenge(
    deviceInput: DeviceInput!
    email: EmailAddress!
  ): DecryptionChallenge

  """
  removes current device. Returns null if user is not authenticated, alias for device logout/remove methods
  """
  logout(removeDevice: Boolean): Int
    @deprecated(reason: "prefer device methods")
  addWebInputs(webInputs: [WebInputElement!]!): [WebInputGQL!]!
  createCheckoutSession(product: String!): String!
}

type UserMutation {
  id: ID!
  email: EmailAddress
  tokenVersion: Int!
  username: String
  uiLocalisation: String!
  addDeviceSecretEncrypted: String!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  deviceRecoveryCooldownMinutes: Int!
  autofill: Boolean!
  language: String!
  theme: String!
  Token: [TokenGQL!]!
  masterDevice: DeviceGQL
  recoveryDecryptionChallenge: DecryptionChallengeGQL
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
  MasterDeviceChange: [MasterDeviceChangeGQL!]!
  addCookie: String!
  device(id: String!): DeviceMutation!
  addDevice(firebaseToken: String!, device: DeviceInput!): DeviceGQL!
  encryptedSecret(id: ID!): EncryptedSecretMutation!
  createSecretUsageEvent(
    event: SecretUsageEventInput!
  ): SecretUsageEventGQLScalars!
  addEncryptedSecrets(
    secrets: [EncryptedSecretInput!]!
  ): [EncryptedSecretQuery!]!
  updateFireToken(firebaseToken: String!): DeviceGQL!
  updateSettings(config: SettingsInput!): UserGQL!
  sendEmailVerification: NonNegativeInt!
  revokeRefreshTokensForUser: UserGQL!
  changeMasterPassword(input: ChangeMasterPasswordInput!): PositiveInt!
  decryptionChallenge(id: Int!): DecryptionChallengeMutation!
  setMasterDevice(newMasterDeviceId: String!): MasterDeviceChangeGQL!
  createCheckoutSession(product: String!): String!
}

type DeviceMutation {
  id: ID!
  firstIpAddress: String!
  lastIpAddress: String!
  firebaseToken: String!
  name: String!
  platform: String!
  ipAddressLock: Boolean!
  logoutAt: DateTime
  syncTOTP: Boolean!
  vaultLockTimeoutSeconds: Int
  createdAt: DateTime!
  updatedAt: DateTime
  registeredWithMasterAt: DateTime
  lastSyncAt: DateTime
  lastUnlockAt: DateTime
  lastLockAt: DateTime
  masterPasswordOutdatedAt: DateTime
  userId: String!
  markAsSynced: DateTime!
  reportSecretUsageEvent(
    webInputId: PositiveInt!
    secretId: UUID!
    kind: String!
  ): SecretUsageEventGQLScalars!
  rename(name: String!): DeviceGQL!
  logout: DeviceGQL!

  """
  user has to approve it when they log in again on that device
  """
  removeDevice: Boolean!
}

type SecretUsageEventGQLScalars {
  id: ID!
  kind: String!
  timestamp: DateTime!
  secretId: String!
  url: String
  userId: String!
  deviceId: String!
  webInputId: Int
}

"""
Integers that will have a value greater than 0.
"""
scalar PositiveInt

input DeviceInput {
  id: UUID!
  name: String!
  platform: String!
}

type EncryptedSecretMutation {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
  SecretUsageEvent: [SecretUsageEventGQL!]!
  lastUsedAt: DateTime
  update(patch: EncryptedSecretInput!): EncryptedSecretGQL!
  delete: EncryptedSecretGQL!
}

input EncryptedSecretInput {
  kind: EncryptedSecretType!
  url: String
  iconUrl: String
  iosUri: String
  androidUri: String
  label: String!
  encrypted: String!
}

input SecretUsageEventInput {
  kind: String!
  secretId: String!
  url: String
}

input SettingsInput {
  syncTOTP: Boolean!
  vaultLockTimeoutSeconds: Int!
  autofill: Boolean!
  language: String!
  theme: String!
}

"""
Integers that will have a value of 0 or more.
"""
scalar NonNegativeInt

input ChangeMasterPasswordInput {
  secrets: [EncryptedSecretPatchInput!]!
  addDeviceSecret: NonEmptyString!
  addDeviceSecretEncrypted: NonEmptyString!
  decryptionChallengeId: PositiveInt!
}

input EncryptedSecretPatchInput {
  kind: EncryptedSecretType!
  url: String
  iconUrl: String
  iosUri: String
  androidUri: String
  label: String!
  encrypted: String!
  id: UUID!
}

"""
A string that cannot be passed as an empty value
"""
scalar NonEmptyString

type DecryptionChallengeMutation {
  id: Int!
  masterPasswordVerifiedAt: DateTime
  approvedAt: DateTime
  rejectedAt: DateTime
  blockIp: Boolean
  deviceName: String!
  deviceId: String!
  userId: String!
  createdAt: DateTime!
  approvedByRecovery: Boolean!
  approvedFromDeviceId: String
  user: UserGQL!
  approvedFromDevice: DeviceGQL
  User: [UserGQL!]!
  approve: DecryptionChallengeGQL!
  reject: DecryptionChallengeGQL!
  recoverAccount: DecryptionChallengeGQL!
}

type LoginResponse {
  accessToken: String!
  user: UserMutation!
  encryptionSalt: String!
}

input RegisterNewAccountInput {
  firebaseToken: String!
  addDeviceSecret: NonEmptyString!
  addDeviceSecretEncrypted: NonEmptyString!
  deviceId: UUID!
  deviceName: String!
  devicePlatform: String!
  encryptionSalt: NonEmptyString!
  email: EmailAddress!
}

union DecryptionChallenge =
    DecryptionChallengeApproved
  | DecryptionChallengeForApproval

type DecryptionChallengeApproved {
  id: Int!
  masterPasswordVerifiedAt: DateTime
  approvedAt: DateTime!
  rejectedAt: DateTime
  blockIp: Boolean
  deviceName: String!
  deviceId: String!
  userId: String!
  createdAt: DateTime!
  approvedByRecovery: Boolean!
  approvedFromDeviceId: String
  user: UserGQL!
  approvedFromDevice: DeviceGQL
  User: [UserGQL!]!
  addDeviceSecretEncrypted: String!
  encryptionSalt: String!
  addNewDeviceForUser(
    currentAddDeviceSecret: NonEmptyString!
    input: AddNewDeviceInput!
  ): LoginResponse!
}

input AddNewDeviceInput {
  firebaseToken: String!
  addDeviceSecret: NonEmptyString!
  addDeviceSecretEncrypted: NonEmptyString!
}

input WebInputElement {
  domPath: String!
  domOrdinal: PositiveInt!
  url: String!
  kind: WebInputType!
}
