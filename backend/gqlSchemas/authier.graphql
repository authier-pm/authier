type Query {
  user(userId: String!): UserQuery

  """
  you need to be authenticated to call this resolver
  """
  authenticated: Boolean!
  me: UserQuery
  currentDevice: DeviceQuery!
  webInputs(url: String!): [WebInputGQL!]!
}

type UserQuery {
  id: ID!
  email: EmailAddress
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  Token: [TokenGQL!]!
  masterDevice: DeviceGQL
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
  devices: [DeviceQuery!]!
  lastChangeInSecrets: DateTime
  devicesCount: Int!
  settings: SettingsConfigGQL!
  encryptedSecrets(fromDate: DateTime): [EncryptedSecretQuery!]!
  sendAuthMessage(
    pageName: String!
    device: String!
    time: DateTime!
    location: String!
  ): Boolean!
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

type TokenGQL {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime
  type: TokenType!
  emailToken: String
  valid: Boolean!
  expiration: DateTime!
  userId: String!
  user: UserGQL!
}

enum TokenType {
  EMAIL
  API
}

type UserGQL {
  id: ID!
  email: String
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  Token: [TokenGQL!]!
  masterDevice: DeviceGQL
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
}

type DeviceGQL {
  id: ID!
  firstIpAddress: String!
  lastIpAddress: String!
  firebaseToken: String!
  name: String!
  syncTOTP: Boolean!
  ipAddressLock: Boolean!
  vaultLockTimeoutSeconds: Int
  logoutAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime
  registeredWithMasterAt: DateTime
  lastSyncAt: DateTime
  masterPasswordOutdatedAt: DateTime
  userId: String!
  User: UserGQL!
  UserMaster: UserGQL
  SecretUsageEvents: [SecretUsageEventGQL!]!
  DeviceDecryptionChallengesApproved: [DecryptionChallengeGQL!]!
}

type SecretUsageEventGQL {
  id: ID!
  kind: String!
  timestamp: DateTime!
  secretId: String!
  url: String
  userId: String!
  deviceId: String!
  webInputId: Int
  Secret: EncryptedSecretGQL!
  User: UserGQL!
  Device: DeviceGQL!
  WebOTPInput: WebInputGQL
}

type EncryptedSecretGQL {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
  SecretUsageEvent: [SecretUsageEventGQL!]!
}

enum EncryptedSecretType {
  TOTP
  LOGIN_CREDENTIALS
}

type WebInputGQL {
  id: Int!
  layoutType: String
  createdAt: DateTime!
  url: String!
  kind: WebInputType!
  domPath: String!
  addedByUserId: String!
  addedByUser: UserGQL!
  UsageEvents: [SecretUsageEventGQL!]!
}

enum WebInputType {
  TOTP
  USERNAME
  EMAIL
  USERNAME_OR_EMAIL
  PASSWORD
}

type DecryptionChallengeGQL {
  id: Int!
  masterPasswordVerifiedAt: DateTime
  approvedAt: DateTime
  userId: String!
  createdAt: DateTime!
  deviceId: String
  approvedFromDeviceId: String
  user: UserGQL!
  approvedFromDevice: DeviceGQL
  addDeviceSecretEncrypted: String!
}

type SettingsConfigGQL {
  userId: ID!
  lockTime: Int!
  twoFA: Boolean!
  noHandsLogin: Boolean!
  homeUI: String!
  updatedAt: DateTime
  user: UserGQL!
}

type TagGQL {
  id: Int!
  name: String!
  createdAt: DateTime!
  userId: String!
  user: UserGQL!
}

type UserPaidProductsGQL {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime
  expiresAt: DateTime
  productId: String!
  userId: String!
  checkoutSessionId: String!
  user: UserGQL!
}

type DeviceQuery {
  id: ID!
  firstIpAddress: String!
  lastIpAddress: String!
  firebaseToken: String!
  name: String!
  syncTOTP: Boolean!
  ipAddressLock: Boolean!
  vaultLockTimeoutSeconds: Int
  logoutAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime
  registeredWithMasterAt: DateTime
  lastSyncAt: DateTime
  masterPasswordOutdatedAt: DateTime
  userId: String!
  User: UserGQL!
  UserMaster: UserGQL
  SecretUsageEvents: [SecretUsageEventGQL!]!
  DeviceDecryptionChallengesApproved: [DecryptionChallengeGQL!]!
  encryptedSecretsToSync: [EncryptedSecretQuery!]!
  lastGeoLocation: String!
}

type EncryptedSecretQuery {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
  SecretUsageEvent: [SecretUsageEventGQL!]!
}

type Mutation {
  user(userId: String!): UserMutation

  """
  you need to be authenticated to call this resolver
  """
  me: UserMutation!
  currentDevice: DeviceMutation!
  registerNewUser(userId: UUID!, input: RegisterDeviceInput!): LoginResponse!
  addNewDeviceForUser(
    currentAddDeviceSecret: NonEmptyString!
    input: RegisterDeviceInput!
  ): LoginResponse!

  """
  returns a decryption challenge
  """
  deviceDecryptionChallenge(
    deviceId: UUID!
    email: EmailAddress!
  ): DecryptionChallengeGQL

  """
  removes current device
  """
  logout: Boolean
  addWebInputs(webInputs: [WebInputElement!]!): [WebInputGQL!]!
}

type UserMutation {
  id: ID!
  email: EmailAddress
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  Token: [TokenGQL!]!
  masterDevice: DeviceGQL
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
  addCookie: String!
  addDevice(
    firebaseToken: String!
    deviceId: String!
    name: String!
  ): DeviceGQL!
  encryptedSecret(id: ID!): EncryptedSecretMutation!
  addEncryptedSecret(payload: EncryptedSecretInput!): EncryptedSecretQuery!
  updateFireToken(firebaseToken: String!): DeviceGQL!
  updateSettings(
    noHandsLogin: Boolean!
    lockTime: Int!
    homeUI: String!
    twoFA: Boolean!
  ): SettingsConfigGQL!
  revokeRefreshTokensForUser: UserGQL!
  approveDevice(success: Boolean!): Boolean!
}

type EncryptedSecretMutation {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
  SecretUsageEvent: [SecretUsageEventGQL!]!
  update(payload: EncryptedSecretInput!): EncryptedSecretGQL!
  delete: EncryptedSecretGQL!
}

input EncryptedSecretInput {
  kind: EncryptedSecretType!
  url: String!
  iconUrl: String
  iosUri: String
  androidUri: String
  label: String!
  encrypted: String!
}

type DeviceMutation {
  id: ID!
  firstIpAddress: String!
  lastIpAddress: String!
  firebaseToken: String!
  name: String!
  syncTOTP: Boolean!
  ipAddressLock: Boolean!
  vaultLockTimeoutSeconds: Int
  logoutAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime
  registeredWithMasterAt: DateTime
  lastSyncAt: DateTime
  masterPasswordOutdatedAt: DateTime
  userId: String!
  markAsSynced: DateTime!
  reportSecretUsageEvent(
    webInputId: PositiveInt!
    secretId: UUID!
    kind: String!
  ): SecretUsageEventGQLScalars!
}

type SecretUsageEventGQLScalars {
  id: ID!
  kind: String!
  timestamp: DateTime!
  secretId: String!
  url: String
  userId: String!
  deviceId: String!
  webInputId: Int
}

"""
Integers that will have a value greater than 0.
"""
scalar PositiveInt

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

type LoginResponse {
  accessToken: String!
  user: UserAfterAuth!
}

type UserAfterAuth {
  id: ID!
  email: String
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  Token: [TokenGQL!]!
  masterDevice: DeviceGQL
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
}

input RegisterDeviceInput {
  email: EmailAddress!
  deviceName: String!
  deviceId: UUID!
  firebaseToken: String!
  addDeviceSecret: NonEmptyString!
  addDeviceSecretEncrypted: NonEmptyString!
  decryptionChallengeId: PositiveInt!
}

"""
A string that cannot be passed as an empty value
"""
scalar NonEmptyString

input WebInputElement {
  domPath: String!
  url: String!
  kind: WebInputType!
}
