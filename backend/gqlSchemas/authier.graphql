type Query {
  user(userId: String!): UserQuery

  """
  you need to be authenticated to call this resolver
  """
  authenticated: Boolean!
  me: UserQuery!
  currentDevice: UserQuery!
  webInputs(url: String!): [WebInputGQL!]!
}

type UserQuery {
  id: ID!
  email: EmailAddress
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  Token: [TokenGQL!]!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDevice: DeviceGQL
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
  devices: [DeviceGQL!]!
  lastChangeInSecrets: DateTime
  devicesCount: Int!
  settings: SettingsConfigGQL!
  encryptedSecrets: [EncryptedSecretQuery!]!
  sendAuthMessage(
    pageName: String!
    device: String!
    time: String!
    location: String!
  ): Boolean!
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

type TokenGQL {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  type: TokenType!
  emailToken: String
  valid: Boolean!
  expiration: DateTime!
  user: UserGQL!
  userId: String!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

enum TokenType {
  EMAIL
  API
}

type UserGQL {
  id: ID!
  email: String
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  Token: [TokenGQL!]!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDevice: DeviceGQL
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
}

type DeviceGQL {
  id: ID!
  firstIpAddress: String!
  lastIpAddress: String!
  firebaseToken: String!
  name: String!
  syncTOTP: Boolean!
  ipAddressLock: Boolean!
  vaultLockTimeoutSeconds: Int
  createdAt: DateTime!
  updatedAt: DateTime
  registeredWithMasterAt: DateTime
  lastSyncAt: DateTime
  masterPasswordOutdatedAt: DateTime
  userId: String!
  User: UserGQL!
  UserMaster: UserGQL
  SecretUsageEvents: [SecretUsageEventGQL!]!
  DeviceDecryptionChallenges: [DecryptionChallengeGQL!]!
  DeviceDecryptionChallengesApproved: [DecryptionChallengeGQL!]!
}

type SecretUsageEventGQL {
  id: ID!
  kind: String!
  timestamp: DateTime!
  url: String!
  User: UserGQL!
  userId: String!
  Device: DeviceGQL!
  deviceId: String!
  webInputId: Int
  WebOTPInput: WebInputGQL
  EncryptedSecret: [EncryptedSecretGQL!]!
}

type WebInputGQL {
  id: ID!
  layoutType: String
  createdAt: DateTime!
  url: String!
  kind: WebInputType!
  domPath: String!
  addedByUser: UserGQL!
  addedByUserId: String!
  UsageEvents: [SecretUsageEventGQL!]!
}

enum WebInputType {
  TOTP
  USERNAME
  EMAIL
  USERNAME_OR_EMAIL
  PASSWORD
}

type EncryptedSecretGQL {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  lastUsageEventId: Float
  lastUsageEvent: SecretUsageEventGQL
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
}

enum EncryptedSecretType {
  TOTP
  LOGIN_CREDENTIALS
}

type DecryptionChallengeGQL {
  id: ID!
  masterPasswordVerifiedAt: DateTime
  approvedAt: DateTime
  userId: String!
  user: UserGQL!
  createdAt: DateTime!
  deviceId: String
  device: DeviceGQL
  approvedFromDeviceId: String
  approvedFromDevice: DeviceGQL
  addDeviceSecretEncrypted: String!
}

type SettingsConfigGQL {
  userId: ID!
  lockTime: Int!
  twoFA: Boolean!
  noHandsLogin: Boolean!
  homeUI: String!
  updatedAt: DateTime
  user: UserGQL!
}

type TagGQL {
  id: ID!
  name: String!
  createdAt: DateTime!
  user: UserGQL!
  userId: String!
}

type UserPaidProductsGQL {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  expiresAt: DateTime
  productId: String!
  userId: String!
  user: UserGQL!
  checkoutSessionId: String!
}

type EncryptedSecretQuery {
  id: ID!
  encrypted: String!
  version: Int!
  kind: EncryptedSecretType!
  createdAt: DateTime!
  updatedAt: DateTime
  url: String
  androidUri: String
  iosUri: String
  lastUsageEventId: Float
  lastUsageEvent: SecretUsageEventGQL
  iconUrl: String
  label: String!
  userId: String!
  user: UserGQL!
}

type Mutation {
  user(userId: String!): UserMutation

  """
  you need to be authenticated to call this resolver
  """
  me: UserMutation
  registerNewUser(userId: UUID!, input: RegisterNewDeviceInput!): LoginResponse!
  addNewDeviceForUser(
    currentAddDeviceSecret: String!
    input: RegisterNewDeviceInput!
  ): LoginResponse!

  """
  returns a decryption challenge
  """
  deviceDecryptionChallenge(email: EmailAddress!): DecryptionChallengeGQL

  """
  removes current device
  """
  logout: Boolean
  addWebInputs(webInputs: [WebInputElement!]!): [WebInputGQL!]!
}

type UserMutation {
  id: ID!
  email: EmailAddress
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  Token: [TokenGQL!]!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDevice: DeviceGQL
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
  addCookie: Boolean!
  addDevice(
    firebaseToken: String!
    deviceId: String!
    name: String!
  ): DeviceGQL!
  addEncryptedSecret(payload: EncryptedSecretInput!): EncryptedSecretQuery!
  updateFireToken(firebaseToken: String!): DeviceGQL!
  updateSettings(
    noHandsLogin: Boolean!
    lockTime: Int!
    homeUI: String!
    twoFA: Boolean!
  ): SettingsConfigGQL!
  revokeRefreshTokensForUser: UserGQL!
  approveDevice(success: Boolean!): Boolean!
}

input EncryptedSecretInput {
  kind: EncryptedSecretType!
  url: String
  iosUri: String
  androidUri: String
  label: String!
  encrypted: String!
}

type LoginResponse {
  accessToken: String!
  user: UserAfterAuth!
}

type UserAfterAuth {
  id: ID!
  email: String
  tokenVersion: Int!
  username: String
  addDeviceSecretEncrypted: String!
  Token: [TokenGQL!]!
  createdAt: DateTime!
  updatedAt: DateTime
  masterDevice: DeviceGQL
  masterDeviceId: String
  TOTPlimit: Int!
  loginCredentialsLimit: Int!
  UsageEvents: [SecretUsageEventGQL!]!
  EncryptedSecrets: [EncryptedSecretGQL!]!
  Devices: [DeviceGQL!]!
  WebInputsAdded: [WebInputGQL!]!
  SettingsConfigs: [SettingsConfigGQL!]!
  Tags: [TagGQL!]!
  UserPaidProducts: [UserPaidProductsGQL!]!
  DecryptionChallenges: [DecryptionChallengeGQL!]!
}

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

input RegisterNewDeviceInput {
  email: EmailAddress!
  deviceName: String!
  deviceId: String!
  firebaseToken: String!
  addDeviceSecret: String!
  addDeviceSecretEncrypted: String!
}

input WebInputElement {
  domPath: String!
  url: String!
  kind: WebInputType!
}
