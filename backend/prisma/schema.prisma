datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")

}

generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["selectRelationCount"]
}

generator typegraphql {
    provider = "typegraphql-prisma"
    output   = "../generated/typegraphql-prisma"
}

model EncryptedAuths {
    id        Int    @id @default(autoincrement())
    encrypted String
    version   Int
    userId    String @unique @db.Uuid

    createdAt DateTime  @default(now())
    updatedAt DateTime? @updatedAt

    user User @relation(fields: [userId], references: [id])
}

model Device {
    id                      Int    @id @default(autoincrement())
    firstIpAdress           String @db.Inet
    lastIpAdress            String @db.Inet
    firebaseToken           String
    name                    String
    vaultLockTimeoutSeconds Int?

    createdAt DateTime  @default(now())
    updatedAt DateTime? @updatedAt

    VaultUnlockEvents         VaultUnlockEvents[] @relation("device")
    VaultUnlockEventsApproved VaultUnlockEvents[] @relation("approvedFromDevice")

    userId String @db.Uuid
    User   User   @relation("devices", fields: [userId], references: [id])

    UserPrimary User? @relation("primaryDevice")
}

model SettingsConfig {
    id       Int     @id @default(autoincrement())
    lockTime Int
    TwoFA    Boolean

}

// recorded when user shows a code for manual entry or when the code is filled into input by authier extension
model OTPCodeEvent {
    id            BigInt       @id @default(autoincrement())
    kind          String
    timestamp     DateTime     @default(now())
    ipAdress      String       @db.Inet
    url           String
    User          User         @relation(fields: [userId], references: [id])
    userId        String       @db.Uuid
    webOTPInputId Int? // this will be null when it was inputted manually
    WebOTPInput   WebOTPInput? @relation(fields: [webOTPInputId], references: [id])
}

// recorded whenever user unlocks vault
model VaultUnlockEvents {
    id             Int       @id @default(autoincrement())
    deviceIp       String    @db.Inet
    approvedFromIp String?   @db.Inet
    approvedAt     DateTime?

    deviceId             Int
    device               Device  @relation("device", fields: [deviceId], references: [id])
    approvedFromDeviceId Int? // when non null it means user unlocked by using another device
    approvedFromDevice   Device? @relation("approvedFromDevice", fields: [approvedFromDeviceId], references: [id])

}

// a map of all inputs publicly available on the internet
model WebOTPInput {
    id              Int            @id @default(autoincrement())
    kind            String
    createdAt       DateTime       @default(now())
    url             String
    domPath         String
    createdByUser   User           @relation(fields: [createdByUserId], references: [id])
    createdByUserId String         @db.Uuid
    OTPCodeEvent    OTPCodeEvent[]
}

model User {
    id              String          @id @default(uuid()) @db.Uuid
    email           String?         @unique
    phone_number    String?         @unique
    account_name    String?         @unique
    password        String
    tokenVersion    Int             @default(0)
    name            String?
    auths           EncryptedAuths?
    Token           Token[]
    createdAt       DateTime        @default(now())
    updatedAt       DateTime        @updatedAt
    primaryDevice   Device?         @relation("primaryDevice", fields: [primaryDeviceId], references: [id])
    primaryDeviceId Int?

    OTPCodeEvents OTPCodeEvent[]
    Devices       Device[]       @relation("devices")
    WebOTPInputs  WebOTPInput[]
}

model Token {
    id         Int       @id @default(autoincrement())
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt
    type       TokenType
    emailToken String?   @unique // Only used for short lived email tokens
    valid      Boolean   @default(true)
    expiration DateTime

    // Relation fields
    user   User   @relation(fields: [userId], references: [id])
    userId String @db.Uuid
}

enum TokenType {
    EMAIL // used as a short-lived token sent to the user's email
    API
}
