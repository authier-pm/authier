datasource db {
  provider             = "postgresql"
  url                  = env("DATABASE_URL")
  referentialIntegrity = "foreignKeys"
}

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = ["native", "linux-arm64-openssl-1.0.x"]
  previewFeatures = ["referentialIntegrity"]
}

generator PrismaTypeGraphQLTypesGenerator {
  provider                       = "npx prisma-typegraphql-types-generator"
  modelsOutput                   = "./models/generated"
  enumsOutput                    = "./models/types"
  useYarn                        = true
  removeTypeInFieldDecorator     = true
  splitScalarAndObjectTypeFields = true
  exportedNameSuffix             = "GQL"
}

// this gets created when a user asks for a new Decryption Challenge in order to login on a new device
model DecryptionChallenge {
  id                       Int       @id @default(autoincrement())
  // @skip
  ipAddress                String    @db.Inet
  masterPasswordVerifiedAt DateTime?
  approvedAt               DateTime?
  rejectedAt               DateTime?
  blockIp                  Boolean? // when true, attempt to get a new challenge from the same IP address will fail
  deviceName               String
  deviceId                 String    @db.Uuid // no reference as we might want to keep this even when device is deleted
  userId                   String    @db.Uuid
  user                     User      @relation(fields: [userId], references: [id])
  createdAt                DateTime  @default(now())
  approvedByRecovery       Boolean   @default(false)
  approvedFromDeviceId     String?   @db.Uuid // when non null it means user unlocked by using another device
  approvedFromDevice       Device?   @relation("approvedFromDevice", fields: [approvedFromDeviceId], references: [id])
  User                     User[]    @relation("recoveryDecryptionChallenge")
}

model Device {
  id                      String    @id @db.Uuid
  firstIpAddress          String    @db.Inet
  lastIpAddress           String    @db.Inet
  firebaseToken           String
  name                    String
  platform                String // https://github.com/lancedikson/bowser/blob/f09411489ced05811c91cc6670a8e4ca9cbe39a7/src/constants.js#L93
  syncTOTP                Boolean   @default(true) //2FA
  ipAddressLock           Boolean   @default(false) // when enabled, we check ip address and force new approval from master device if the IP changes
  vaultLockTimeoutSeconds Int?
  logoutAt                DateTime?

  createdAt                DateTime  @default(now())
  updatedAt                DateTime? @updatedAt
  registeredWithMasterAt   DateTime?
  lastSyncAt               DateTime?
  lastUnlockAt             DateTime?
  lastLockAt               DateTime?
  masterPasswordOutdatedAt DateTime? // we set it to a timestamp when user changes master password on one device

  userId String @db.Uuid
  User   User   @relation("devices", fields: [userId], references: [id])

  UserMaster User? @relation("masterDevice")

  SecretUsageEvents SecretUsageEvent[]

  DeviceDecryptionChallengesApproved DecryptionChallenge[] @relation("approvedFromDevice")
  @@index([updatedAt])
  @@index([lastSyncAt])
}

model SettingsConfig {
  userId       String    @id @unique @db.Uuid
  lockTime     Int
  twoFA        Boolean
  noHandsLogin Boolean
  homeUI       String
  updatedAt    DateTime? @updatedAt

  user User @relation(fields: [userId], references: [id])
}

// each row contains a single TOTP or Login credential
model EncryptedSecret {
  id        String              @id @default(uuid()) @db.Uuid
  encrypted String // for TOTP and NEW_DEVICE it is a plain string, for LOGIN_CREDENTIALS it is a JSON array: [username, password]
  version   Int
  kind      EncryptedSecretType
  createdAt DateTime            @default(now())
  updatedAt DateTime?           @updatedAt
  deletedAt DateTime?

  // TODO move these 5 fields to encrypted
  url        String? // TODO should always be location.hostname, we autofill inputs based on WebInput where we store the path too
  androidUri String?
  iosUri     String?
  iconUrl    String?
  label      String

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id])

  SecretUsageEvent SecretUsageEvent[]
}

// recorded whenever secret gets used.
// for example:
//   -- displays secret for manual entry
//   -- secret is filled into input by authier extension
//   -- secret is copied to clipboard by user
model SecretUsageEvent {
  id          BigInt          @id @default(autoincrement())
  kind        String
  timestamp   DateTime        @default(now())
  secretId    String          @db.Uuid
  Secret      EncryptedSecret @relation(fields: [secretId], references: [id])
  // @skip
  ipAddress   String          @db.Inet
  url         String?
  User        User            @relation(fields: [userId], references: [id])
  userId      String          @db.Uuid
  Device      Device          @relation(fields: [deviceId], references: [id])
  deviceId    String          @db.Uuid
  webInputId  Int? // this will be null when it was inputted manually
  WebOTPInput WebInput?       @relation(fields: [webInputId], references: [id])

}

// recorded whenever user unlocks vault
// model VaultUnlockEvents {
//     id             Int       @id @default(autoincrement())
//     deviceIp       String    @db.Inet
//     approvedFromIp String?   @db.Inet
//     approvedAt     DateTime?

//     deviceId             String  @db.Uuid
//     device               Device  @relation("device", fields: [deviceId], references: [id])
//     approvedFromDeviceId String? @db.Uuid // when non null it means user unlocked by using another device
//     approvedFromDevice   Device? @relation("approvedFromDevice", fields: [approvedFromDeviceId], references: [id])

// }

// a map of all inputs publicly available on the internet which we need to map in order for authier's automagic login to work
model WebInput {
  id            Int                @id @default(autoincrement())
  layoutType    String? // for OTP inputs can be 'simple' or 'multi' for when pages where they have 6 input elements-one for each OTP code digit
  createdAt     DateTime           @default(now())
  host          String             @db.VarChar(253)
  url           String             @db.VarChar(2048)
  kind          WebInputType
  domPath       String
  domOrdinal    Int                @default(0)
  addedByUser   User               @relation(fields: [addedByUserId], references: [id])
  addedByUserId String             @db.Uuid
  UsageEvents   SecretUsageEvent[]

  @@unique([url, domPath], name: "webInputIdentifier")
  @@index([host])
  @@index([kind])
}

model User {
  id                            String               @id @default(uuid()) @db.Uuid
  email                         String?              @unique @db.Citext
  tokenVersion                  Int                  @default(0)
  username                      String?              @unique
  uiLocalisation                String               @default("en")
  // @skip
  addDeviceSecret               String // random string used when user wants to log in on mobile using a QR code displayed in authier extension
  addDeviceSecretEncrypted      String // client has to decrypt this to prove they have the correct master password
  // @skip
  encryptionSalt                String
  Token                         Token[]
  createdAt                     DateTime             @default(now())
  updatedAt                     DateTime?            @updatedAt
  masterDevice                  Device?              @relation("masterDevice", fields: [masterDeviceId], references: [id])
  masterDeviceId                String?              @unique @db.Uuid
  // Limits for the number of stored secrets
  TOTPlimit                     Int
  loginCredentialsLimit         Int
  // @skip
  recoveryDecryptionChallengeId Int? // when set user is in process of adding a new master device waiting for the cooldown to
  recoveryDecryptionChallenge   DecryptionChallenge? @relation("recoveryDecryptionChallenge", fields: [recoveryDecryptionChallengeId], references: [id])

  deviceRecoveryCooldownMinutes Int // in case if user cannot access any existing device, they can trigger this failsafe

  UsageEvents          SecretUsageEvent[]
  EncryptedSecrets     EncryptedSecret[]
  Devices              Device[]              @relation("devices")
  WebInputsAdded       WebInput[]
  SettingsConfigs      SettingsConfig[]
  Tags                 Tag[]
  UserPaidProducts     UserPaidProducts[]
  DecryptionChallenges DecryptionChallenge[]
  // @skip
  EmailVerification    EmailVerification[]
}

model Token {
  id         Int       @id @default(autoincrement())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime? @updatedAt
  type       TokenType
  emailToken String?   @unique // Only used for short lived email tokens
  valid      Boolean   @default(true)
  expiration DateTime

  // Relation fields
  user   User   @relation(fields: [userId], references: [id])
  userId String @db.Uuid
}

model UserPaidProducts {
  id                Int       @id @default(autoincrement())
  createdAt         DateTime  @default(now())
  updatedAt         DateTime? @updatedAt
  expiresAt         DateTime?
  productId         String    @unique
  userId            String    @db.Uuid
  user              User      @relation(fields: [userId], references: [id])
  checkoutSessionId String
}

enum TokenType {
  EMAIL // used as a short-lived token sent to the user's email
  API
}

enum EncryptedSecretType {
  TOTP // used as a short-lived token sent to the user's email
  LOGIN_CREDENTIALS
}

enum WebInputType {
  TOTP
  USERNAME
  EMAIL
  USERNAME_OR_EMAIL
  PASSWORD
  NEW_PASSWORD
  NEW_PASSWORD_CONFIRMATION
  SUBMIT_BUTTON
  CUSTOM
}

model Tag {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @db.Uuid
}

enum EmailVerificationType {
  PRIMARY
  CONTACT
}

model EmailVerification {
  address    String                @id @db.Citext
  createdAt  DateTime              @default(now())
  verifiedAt DateTime?
  userId     String                @db.Uuid
  user       User                  @relation(fields: [userId], references: [id])
  // @skip
  token      String                @unique @db.Uuid
  kind       EmailVerificationType
}
