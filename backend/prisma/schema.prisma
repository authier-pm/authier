datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")

}

generator client {
    provider = "prisma-client-js"
}

generator PrismaTypeGraphQLTypesGenerator {
    provider                   = "node node_modules/prisma-typegraphql-types-generator"
    modelsOutput               = "./models/generated"
    enumsOutput                = "./models/types"
    useYarn                    = true
    removeTypeInFieldDecorator = true
    exportedNameSuffix         = "GQL"
}

// each row contains a single TOTP or Login credential
model EncryptedSecret {
    id               Int                 @id @default(autoincrement())
    encrypted        String // for TOTP and NEW_DEVICE it is a plain string, for LOGIN_CREDENTIALS it is a JSON array: [username, password]
    version          Int
    userId           String              @db.Uuid
    kind             EncryptedSecretType
    createdAt        DateTime            @default(now())
    updatedAt        DateTime?           @updatedAt
    //uniqueFiled String               @unique
    url              String? // should always be location.hostname, we autofill inputs based on WebInput where we store the path too
    androidUri       String?
    iosUri           String?
    lastUsageEventId BigInt?
    lastUsageEvent   SecretUsageEvent?   @relation("secret", fields: [lastUsageEventId], references: [id])

    iconUrl String?
    label   String
    user    User    @relation(fields: [userId], references: [id])
}

model Device {
    id                      String  @id @db.Uuid
    firstIpAddress          String  @db.Inet
    lastIpAddress           String  @db.Inet
    firebaseToken           String
    name                    String
    syncTOTP                Boolean @default(true)
    ipAddressLock           Boolean @default(false) // when enabled, we check ip address and force new approval from master device if the IP changes
    vaultLockTimeoutSeconds Int?


    createdAt                DateTime  @default(now())
    updatedAt                DateTime? @updatedAt
    registeredWithMasterAt   DateTime?
    lastSyncAt               DateTime?
    masterPasswordOutdatedAt DateTime? // we set it to a timestamp when user changes master password on one device

    VaultUnlockEvents         VaultUnlockEvents[] @relation("device")
    VaultUnlockEventsApproved VaultUnlockEvents[] @relation("approvedFromDevice")

    userId String @db.Uuid
    User   User   @relation("devices", fields: [userId], references: [id])

    UserMaster User? @relation("masterDevice")

    SecretUsageEvents SecretUsageEvent[]
    @@index([updatedAt])
    @@index([lastSyncAt])
}

model SettingsConfig {
    userId       String    @id @unique @db.Uuid
    lockTime     Int
    twoFA        Boolean
    noHandsLogin Boolean
    homeUI       String
    updatedAt    DateTime? @updatedAt

    user User @relation(fields: [userId], references: [id])
}

// recorded whenever secret gets used.
// for example:
//   -- displays secret for manual entry
//   -- secret is filled into input by authier extension
//   -- secret is copied to clipboard by user
model SecretUsageEvent {
    id          BigInt    @id @default(autoincrement())
    kind        String
    timestamp   DateTime  @default(now())
    ipAddress   String    @db.Inet
    url         String
    User        User      @relation(fields: [userId], references: [id])
    userId      String    @db.Uuid
    Device      Device    @relation(fields: [deviceId], references: [id])
    deviceId    String    @db.Uuid
    webInputId  Int? // this will be null when it was inputted manually
    WebOTPInput WebInput? @relation(fields: [webInputId], references: [id])

    EncryptedSecret EncryptedSecret[] @relation("secret")
}

// recorded whenever user unlocks vault
model VaultUnlockEvents {
    id             Int       @id @default(autoincrement())
    deviceIp       String    @db.Inet
    approvedFromIp String?   @db.Inet
    approvedAt     DateTime?

    deviceId             String  @db.Uuid
    device               Device  @relation("device", fields: [deviceId], references: [id])
    approvedFromDeviceId String? @db.Uuid // when non null it means user unlocked by using another device
    approvedFromDevice   Device? @relation("approvedFromDevice", fields: [approvedFromDeviceId], references: [id])

}

// a map of all inputs publicly available on the internet which we need to map in order for authier's automagic login to work
model WebInput {
    id            Int                @id @default(autoincrement())
    layoutType    String? // for OTP inputs can be 'simple' or 'multi' for when pages where they have 6 input elements-one for each OTP code digit
    createdAt     DateTime           @default(now())
    url           String
    kind          WebInputType
    domPath       String
    addedByUser   User               @relation(fields: [addedByUserId], references: [id])
    addedByUserId String             @db.Uuid
    UsageEvents   SecretUsageEvent[]

    @@unique([url, domPath], name: "webInputIdentifier")
}

model User {
    id    String  @id @default(uuid()) @db.Uuid
    email String? @unique

    tokenVersion             Int       @default(0)
    username                 String?   @unique
    /// @TypeGraphQL.omit(output: true)
    addDeviceSecret          String // random string used when user wants to log in on mobile using a QR code displayed in authier extension
    addDeviceSecretEncrypted String // client has to decrypt this to prove they have the correct master password
    Token                    Token[]
    createdAt                DateTime  @default(now())
    updatedAt                DateTime? @updatedAt
    masterDevice             Device?   @relation("masterDevice", fields: [masterDeviceId], references: [id])
    masterDeviceId           String?   @unique @db.Uuid
    // Limits for the number of stored secrets
    TOTPlimit                Int
    loginCredentialsLimit    Int

    UsageEvents      SecretUsageEvent[]
    EncryptedSecrets EncryptedSecret[]
    Devices          Device[]           @relation("devices")
    WebInputsAdded   WebInput[]
    SettingsConfig   SettingsConfig[]
    Tags             Tag[]
    UserPaidProducts UserPaidProducts[]
}

model Token {
    id         Int       @id @default(autoincrement())
    createdAt  DateTime  @default(now())
    updatedAt  DateTime? @updatedAt
    type       TokenType
    emailToken String?   @unique // Only used for short lived email tokens
    valid      Boolean   @default(true)
    expiration DateTime

    // Relation fields
    user   User   @relation(fields: [userId], references: [id])
    userId String @db.Uuid
}

model UserPaidProducts {
    id                Int       @id @default(autoincrement())
    createdAt         DateTime  @default(now())
    updatedAt         DateTime? @updatedAt
    expiresAt         DateTime?
    productId         String    @unique
    userId            String    @db.Uuid
    user              User      @relation(fields: [userId], references: [id])
    checkoutSessionId String
}

enum TokenType {
    EMAIL // used as a short-lived token sent to the user's email
    API
}

enum EncryptedSecretType {
    TOTP // used as a short-lived token sent to the user's email
    LOGIN_CREDENTIALS
}

enum WebInputType {
    TOTP
    USERNAME
    EMAIL
    USERNAME_OR_EMAIL
    PASSWORD
}

model Tag {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    user      User     @relation(fields: [userId], references: [id])
    userId    String   @db.Uuid
}
