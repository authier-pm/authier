datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")

}

generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["selectRelationCount"]
}

generator typegraphql {
    provider    = "typegraphql-prisma"
    output      = "../generated/typegraphql-prisma"
    noResolvers = true
}

model EncryptedSecretsChangeAction {
    id           Int                  @id @default(autoincrement())
    encrypted    String
    userId       String               @unique @db.Uuid
    kind         EncryptedSecretsType
    createdAt    DateTime             @default(now())
    processedAt  DateTime? // master device sets this to a timestamp when it adds this change to
    fromDeviceId Int
    fromDevice   Device               @relation("fromDevice", fields: [fromDeviceId], references: [id])
    user         User                 @relation(fields: [userId], references: [id])
}

// each row contains all of OTP
model EncryptedSecrets {
    id        Int                  @id @default(autoincrement())
    encrypted String
    version   Int
    userId    String               @db.Uuid
    kind      EncryptedSecretsType
    createdAt DateTime             @default(now())
    updatedAt DateTime?            @updatedAt
    //uniqueFiled String               @unique

    user User @relation(fields: [userId], references: [id])
    @@unique([userId, kind])
}

model Device {
    id                      Int    @id @default(autoincrement())
    firstIpAddress          String @db.Inet
    lastIpAddress           String @db.Inet
    firebaseToken           String
    name                    String
    vaultLockTimeoutSeconds Int?


    createdAt              DateTime  @default(now())
    updatedAt              DateTime? @updatedAt
    registeredWithMasterAt DateTime?

    VaultUnlockEvents         VaultUnlockEvents[] @relation("device")
    VaultUnlockEventsApproved VaultUnlockEvents[] @relation("approvedFromDevice")

    userId String @db.Uuid
    User   User   @relation("devices", fields: [userId], references: [id])

    UserMaster       User?                          @relation("masterDevice")
    EncryptedChanges EncryptedSecretsChangeAction[] @relation("fromDevice")
}

model SettingsConfig {
    userId       String   @id @unique @db.Uuid
    lockTime     Int
    twoFA        Boolean
    noHandsLogin Boolean
    homeUI       String
    updatedAt    DateTime @updatedAt

    user User @relation(fields: [userId], references: [id])
}

// recorded when user shows a code for manual entry or when the code is filled into input by authier extension
model OTPCodeEvent {
    id          BigInt    @id @default(autoincrement())
    kind        String
    timestamp   DateTime  @default(now())
    ipAddress   String    @db.Inet
    url         String
    User        User      @relation(fields: [userId], references: [id])
    userId      String    @db.Uuid
    webInputId  Int? // this will be null when it was inputted manually
    WebOTPInput WebInput? @relation(fields: [webInputId], references: [id])
}

// recorded whenever user unlocks vault
model VaultUnlockEvents {
    id             Int       @id @default(autoincrement())
    deviceIp       String    @db.Inet
    approvedFromIp String?   @db.Inet
    approvedAt     DateTime?

    deviceId             Int
    device               Device  @relation("device", fields: [deviceId], references: [id])
    approvedFromDeviceId Int? // when non null it means user unlocked by using another device
    approvedFromDevice   Device? @relation("approvedFromDevice", fields: [approvedFromDeviceId], references: [id])

}

// a map of all inputs publicly available on the internet which we need to map in order for authier's automagic login to work
model WebInput {
    id            Int            @id @default(autoincrement())
    layoutType    String? // for OTP inputs can be 'simple' or 'multi' for when pages where they have 6 input elements-one for each OTP code digit
    createdAt     DateTime       @default(now())
    url           String
    kind          WebInputType
    domPath       String
    addedByUser   User           @relation(fields: [addedByUserId], references: [id])
    addedByUserId String         @db.Uuid
    OTPCodeEvent  OTPCodeEvent[]
}

model User {
    id               String             @id @default(uuid()) @db.Uuid
    email            String?            @unique
    /// @TypeGraphQL.omit(output: true)
    passwordHash     String
    tokenVersion     Int                @default(0)
    name             String?
    EncryptedSecrets EncryptedSecrets[]
    Token            Token[]
    createdAt        DateTime           @default(now())
    updatedAt        DateTime           @updatedAt
    masterDevice     Device?            @relation("masterDevice", fields: [masterDeviceId], references: [id])
    masterDeviceId   Int?

    OTPCodeEvents    OTPCodeEvent[]
    Devices          Device[]                       @relation("devices")
    WebInputsAdded   WebInput[]
    EncryptedChanges EncryptedSecretsChangeAction[]
    SettingsConfig   SettingsConfig[]
}

model Token {
    id         Int       @id @default(autoincrement())
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt
    type       TokenType
    emailToken String?   @unique // Only used for short lived email tokens
    valid      Boolean   @default(true)
    expiration DateTime

    // Relation fields
    user   User   @relation(fields: [userId], references: [id])
    userId String @db.Uuid
}

enum TokenType {
    EMAIL // used as a short-lived token sent to the user's email
    API
}

enum EncryptedSecretsType {
    TOTP // used as a short-lived token sent to the user's email
    LOGIN_CREDENTIALS
}

enum WebInputType {
    TOTP
    USERNAME
    EMAIL
    USERNAME_OR_EMAIL
    PASSWORD
}
